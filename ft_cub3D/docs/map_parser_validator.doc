//Мап будет выделять в хипе

resolution_handler(line, struct)
{

	//Resolution: R 1920 1089
	// думаю нет нужды как-то обрабатывать переполнение
	
	if (width > 0 && height > 0) //
		 //завершаем работу программы с ошибкой о повторной записи 
	struct.width = strtol(line, указатель, 10)
		если вернуло 0
		то говорим о незаданном значении
	если *указатель != is_space()
		завершаем работу программы с ошибкой 
	struct.height = strtol(line, указатель, 10)
	если вернуло 0
		то говорим о незаданном значении
	идем до конца строки от указателя и проверяем, нет ли там какой фигни
		если есть завершаем работу программы с ошибкой
	если width < 0 || height < 0
		завершаем работу программы с ошибкой о 
		переполнении либо отриц значения подставили))
}

texture_handler(texture_type, line, struct)
{
	// Общий обработчик для всех 
}

map_parser(int fd, t_something *maze_params)
{
	char *line = 0;
	int counter = 0;
	while (get_next_line(fd, &line))
	{
		идем по Line пока он существует
			пока пробельные символы - Дем дальше - continue
							
			тут встретили какую-то суету
			R+пробельный символ
				counter += resolution_handler(Line + i, наша структура)
					
			F+пробельный символ
				counter += floor_color_handler()
			C+пробельный символ
				ceil_color_handler()
			S->
				S+пробельный символ
					sprite_text_handler()
				S+O+пробельный символ
					south_text_handler()
			N+O+пробельный символ
				north_text_handler()
			W+E+пробельный символ
				west_text_handler()
			E+A+пробельный символ
				east_text_handler()
			else if (counter == 7)
				break;
			else 
			       unknown symbol error
			North texture: NO ./path_to_the_north_texture
			South texture: SO ./path_to...
				       WE ./path_
				       EA ./path_
			Sprite texture: S ./path_to_the_sprite_texture
			Floor color:	F 220,100,0
			Ceil color: 	C 255,30,0
	
		free (line);
	}
	//здеь у нас пустой или непустой line
	i = 0;
 	инициализируем обычную структуру в начале,
	в нее будем записывать заранее валидированые массивы  
	while (line + i !=0)
	{	
		валидация на разрешенные символы
		
		в процессе подсчитываем длину max строки + кол-во строк всего
		в процессе запоминаем позицию игрока, если она уже была задана -
		выбрасываем ошибку

		если что какая ошибка чистим структурыыы всеее;
		struct->line;
		gnl(line);
	}	
	Выделяем гигантский двумерный массив m x n
	запускаем flood_fill, который тож в свою очередь если что выбрасывает ошибку
	floot_fill(map array?, posX, posY);
	
	выводим на экран write(1,"Now map is VALID?" ,n);	 

	//пробелы на конце при парсинге path удаляем/не учитываем
	
	// Пустые строки "\n" могут использоваться в файле повсеместно, кроме карты
	// но спайсовых(из исключительно пробельных) нельзя?
	// Параметры игры могут идти в любом порядке
	// За исключением карты, каждый тип информации из элемента может быть разделен 		// одним или несколькими пробелами. Т.е скок хошь каких угодно 
	// спайсов (\t, \n, ...) можно употреблять внутри строки с параметрами


	// ошибка при unknown key, double key, invalid path!, 
	// Должна ли карта отделяться пробелом?
	// Карта всегда идет в файле последней
	/ Карта должна парсится ровно в том виде, в каком она находится
	// в файле. Только пробелы валидная часть карты.
	// Каждый параметр карты начинается с идентификатора(сост из 1 или 
	// двух символов, за которым следует для каждого параметра ко
	// нкретная информация в строгом порядке)
	//карта может состоять только из 4 возможных элементов:
	//0 - пустое пространство
	//1 - стены
	//2 - предмет
	//N/S/W/E - стартовое положение игрока с указанием ориентации
	//карта должна быть полностью закрыта/окружена стенами
	// или все-таки только игрок?

	//ошибка при незакрытой карте, запрещенных элементах на карте 
	"Error\n" "invalid map"
}
